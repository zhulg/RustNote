<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust学习精简笔记</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="README.zh.html">介绍</a></li><li class="chapter-item expanded "><a href="RustNote0.html"><strong aria-hidden="true">1.</strong> Rust基础语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RustNote1.html"><strong aria-hidden="true">1.1.</strong> 精简笔记一</a></li><li class="chapter-item expanded "><a href="RustNote2.html"><strong aria-hidden="true">1.2.</strong> 精简笔记二</a></li><li class="chapter-item expanded "><a href="RustNote3.html"><strong aria-hidden="true">1.3.</strong> 精简笔记三</a></li></ol></li><li class="chapter-item expanded "><a href="RustNote4.html"><strong aria-hidden="true">2.</strong> Rust疑难知识点</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="RustNote5.html"><strong aria-hidden="true">2.1.</strong> 声明周期</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust学习精简笔记</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<h2 id="适用对象"><a class="header" href="#适用对象">适用对象：</a></h2>
<ul>
<li>适用对Rust感兴趣，想快速学习上手（多学几轮）</li>
<li>Rust知识点速查、回顾、易混淆问题总结。</li>
<li>深入扩展需继续对应官网，真知实践。</li>
</ul>
<h2 id="参考来源"><a class="header" href="#参考来源">参考来源：</a></h2>
<ul>
<li>个人学习Rust知识点汇总。</li>
<li><em>参考The Rust Programming Language &amp;  Rust in Action</em></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础语法总结"><a class="header" href="#基础语法总结">基础语法总结</a></h1>
<ul>
<li>该部分主要对Rust基础语法的汇总及回顾</li>
</ul>
<h2 id="目的"><a class="header" href="#目的">目的</a></h2>
<ul>
<li>反复对基础语法回顾，从基础到深刻学习反复推进</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="精简笔记-一"><a class="header" href="#精简笔记-一">精简笔记 一</a></h1>
<h2 id="一变量"><a class="header" href="#一变量">一.<strong>变量：</strong></a></h2>
<ul>
<li><strong>变量声明使用let, 默认为不可变（即只读），声明可变变量 mut （可读写）</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let x = 5;  //类型可以由编译器自动推断出来
 let y: i32 = 6;  //或者是在创建变量时，声明类型
 let z = 7i32;  //数字类型，可以在数字字面量中加入类型注解
<span class="boring">}
</span></code></pre></pre>
<h2 id="二基本数据类型"><a class="header" href="#二基本数据类型">二.<strong>基本数据类型：</strong></a></h2>
<h4 id="数字类型"><a class="header" href="#数字类型">数字类型:</a></h4>
<ul>
<li>分为有符号和无符号整数，浮点数类型、特定平台的整数</li>
<li><strong>每一个有符号的变体可以储存包含从 -2<sup>n-1</sup> 到2<sup>n-1</sup>-1 在内的数字</strong>，这里 n 是变体使用的位数。如：i8 范围（-128-127）</li>
<li><strong>无符号的范围为0到 2<sup>n</sup>-1</strong>，如: u8 范围（0-255）(00000000 - 11111111)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>类型</th><th>长度</th><th>描述</th></tr></thead><tbody>
<tr><td>i8, i16, i32, i64, i128</td><td>8,16,32,64,64,128 (bit)</td><td>有符号整数</td></tr>
<tr><td>u8, u16, u32, u64, u128</td><td>8,16,32,64,64,128 (bit)</td><td>无符号整数</td></tr>
<tr><td>f32, f64</td><td>32,64(位)</td><td>f32 是单精度浮点数，f64 是双精度浮点数</td></tr>
<tr><td>isize,  usize</td><td>32或64</td><td>32 位架构上它们是 32 位的，64 位架构上它们是 64 位的</td></tr>
</tbody></table>
</div>
<h4 id="rust中的整型字面值"><a class="header" href="#rust中的整型字面值">Rust中的整型字面值:</a></h4>
<div class="table-wrapper"><table><thead><tr><th>数字字面值</th><th>描述</th></tr></thead><tbody>
<tr><td>Decimal (十进制)</td><td>1_100 （使用 _ 做为分隔符以方便读数）</td></tr>
<tr><td>Hex (十六进制)</td><td>0xff（0x开头）</td></tr>
<tr><td>Octal (八进制)</td><td>0o77 （0o开头）</td></tr>
<tr><td>Binary (二进制)</td><td>0b1111_0000（0b开头）</td></tr>
<tr><td>Byte (单字节字符)(仅限于u8)</td><td>b'A'（b开头）</td></tr>
</tbody></table>
</div>
<h4 id="布尔类型-bool"><a class="header" href="#布尔类型-bool">布尔类型 bool：</a></h4>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;
    let f: bool = false; // with explicit type annotation
}

</code></pre></pre>
<h4 id="复合类型"><a class="header" href="#复合类型">复合类型：</a></h4>
<ul>
<li>
<p><strong>元组（tuple）和数组（array）</strong></p>
</li>
<li>
<p><strong>Tuple</strong>: 将多个其他类型的值组合进一个复合类型，声明后长度固定，索引下标从0开始.</p>
</li>
</ul>
<pre><code>    let tup: (i32, f64, u8) = (500, 8.4, 2); //声明类型
    let score = (&quot;Team A&quot;, 12); //自推断
    let five_hundred = tup.0; //取出元组里的500，下标0
</code></pre>
<ul>
<li><strong>array</strong>: 数组里数据类型必现一致，长度固定</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5]; // 自推断
let b: [i32; 5] = [1, 2, 3, 4, 5]; // 在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。
let c = [3; 5]; //变量名为c的数组将包含 5 个元素,数值都为3，等价与let a = [3, 3, 3, 3, 3]
<span class="boring">}
</span></code></pre></pre>
<h2 id="三-流程控制"><a class="header" href="#三-流程控制">三. 流程控制</a></h2>
<h4 id="if---if-let"><a class="header" href="#if---if-let">if &amp;  if let：</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let number = 3;
    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
    
  // match pattern and assign variable
    if let Some(i) = num {
        println!(&quot;number is: {}&quot;, i);
    }
   // if let 语法让我们以一种不那么冗长的方式结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况
<span class="boring">}
</span></code></pre></pre>
<h4 id="loop"><a class="header" href="#loop">loop:</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut count = 0;
    loop {
        count += 1;
        if count == 4 {
            println!(&quot;break&quot;);
            break;
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Nested loops &amp; labels (循环标签): 如果存在嵌套循环在一个循环上指定一个 循环标签（loop label) 标识为'名字</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    'outer: loop {
        'inner: loop {
            break; // This breaks the inner loop
            break 'outer; //   // This breaks the outer loop
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h4 id="while---while-let"><a class="header" href="#while---while-let">while &amp;  while let:</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    while n &lt; 101 {
        n += 1;
    }
    let mut optional = Some(0);
    while let Some(i) = optional {
        print!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<h4 id="for-遍历集合"><a class="header" href="#for-遍历集合">for 遍历集合:</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let a = [10, 20, 30, 40, 50];
    for element in a {
        println!(&quot;the value is: {element}&quot;);
    }
    
    //使用iter()
    let array = [(1, 2), (2, 3)];
    for (x, y) in array.iter() {
        // x, y accessible in loop body only
        println!(&quot;x={},y={}&quot;, x, y);
    }
<span class="boring">}
</span></code></pre></pre>
<h4 id="match"><a class="header" href="#match">match:</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let optional = Some(0);
    match optional {
        Some(i) =&gt; println!(&quot;{}&quot;, i),
        None =&gt; println!(&quot;No value.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="四所有权引用借用"><a class="header" href="#四所有权引用借用">四.所有权&amp;引用&amp;借用</a></h2>
<h4 id="所有权规则"><a class="header" href="#所有权规则">所有权规则:</a></h4>
<pre><code>Rust 中的每一个值都有一个 所有者（owner）
值在任一时刻有且只有一个所有者
当所有者（变量）离开作用域，这个值将被丢弃
</code></pre>
<h4 id="借用规则引用的行为"><a class="header" href="#借用规则引用的行为">借用规则：(引用的行为)</a></h4>
<pre><code>同一作用域内，一个资源要么有一个可变引用，要么存在多个不可变引用
引用总是有效的
</code></pre>
<h4 id="string引用"><a class="header" href="#string引用">String引用：</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello world!&quot;);
    let s1_ref = s1; // immutable reference
    let mut s2 = String::from(&quot;hello&quot;);
    let s2_ref = &amp;mut s2; // mutable reference
    s2_ref.push_str(&quot; world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>函数里使用值，<strong>但不获取所有权, 使用&amp;，获取变量引用 ，仅读权限</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len = calculate_length(&amp;s1);
    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<ul>
<li>函数里参数可变引用, <strong>使用&amp;mut ，获取变量可变操作</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}
//  对参数声明&amp;mut ，操作写字符
fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
    println!(&quot;{}&quot;, some_string);
}
</code></pre></pre>
<h4 id="操作符对应的权限"><a class="header" href="#操作符对应的权限">操作符对应的权限：</a></h4>
<pre><code>x   不可变的值（所有权）
&amp;x  x不可变的引用 （只读）
&amp;mut x  x的可变引用（读写）
</code></pre>
<h4 id="字符串-slice"><a class="header" href="#字符串-slice">字符串 slice:</a></h4>
<ul>
<li>slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，它没有所有权</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
}

</code></pre></pre>
<h2 id="五-struct"><a class="header" href="#五-struct">五. struct</a></h2>
<ul>
<li><strong>普通结构体： struct+一个名字，在大括号中每一部分可以是不同类型，定义每一部分数据的名字和类型，称之为结构体字段</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

<span class="boring">}
</span></code></pre></pre>
<ul>
<li>创建一个实例需要以结构体的名字开头，接着在大括号中使用 key: value 键-值对的形式提供字段</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let userinfo = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<h4 id="元组结构体tuple-structs"><a class="header" href="#元组结构体tuple-structs">元组结构体（tuple structs):</a></h4>
<ul>
<li>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
</code></pre></pre>
<h4 id="类单元结构体unit-like-structs"><a class="header" href="#类单元结构体unit-like-structs">类单元结构体（unit-like structs）:</a></h4>
<ul>
<li>没有任何字段的结构体</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;
fn main() {
    let subject = AlwaysEqual;
}
</code></pre></pre>
<h4 id="impl为结构体添加方法"><a class="header" href="#impl为结构体添加方法">impl为结构体添加方法：</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

<span class="boring">}
</span></code></pre></pre>
<ul>
<li>&amp;self 实际上是 self: &amp;Self 的缩写。在一个 impl 块中，Self 类型是 impl 块的类型的别名。方法的第一个参数必须有一个名为 self 的Self 类型的参数</li>
</ul>
<h4 id="impl里的关联函数"><a class="header" href="#impl里的关联函数">impl里的关联函数：</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rectangle {
    fn square(size: u32) -&gt; Self {
        Self {
            width: size,
            height: size,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>所有在 impl 块中定义的函数被称为 <strong>关联函数（associated functions</strong>），因为它们与 impl 后面命名的类型相关。我们可以定义不以 self 为第一参数的关联函数（因此不是方法），因为它们并不作用于一个结构体的实例</p>
</li>
<li>
<p><strong>多个 impl 块</strong>： 每个结构体都允许拥有多个 impl 块, 但一个方法只能属于一个impl块。</p>
</li>
</ul>
<h2 id="六enum"><a class="header" href="#六enum">六.Enum</a></h2>
<ul>
<li>结构体给予将字段和数据聚合在一起的方法，像 Rectangle 结构体有 width 和 height 两个字段。而枚举给予你将一个值成为一个集合之一的方法。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}

fn route(ip_kind: IpAddrKind) {}

</code></pre></pre>
<h4 id="枚举可以包含不同的类型"><a class="header" href="#枚举可以包含不同的类型"><strong>枚举可以包含不同的类型:</strong></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit, // 没有关联任何数据
    Move { x: i32, y: i32 }, //类似结构体包含命名字段
    Write(String), //包含单独一个 String
    ChangeColor(i32, i32, i32), //包含三个 i32
}

<span class="boring">}
</span></code></pre></pre>
<ul>
<li>结构体和枚举还有另一个相似点：<strong>就像可以使用 impl 来为结构体定义方法那样</strong>，也可以在枚举上定义方法。这是一个定义于我们 Message 枚举上的叫做 call 的方法：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }

    impl Message {
        fn call(&amp;self) {
            // 在这里定义方法体
        }
    }

    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
}

</code></pre></pre>
<h4 id="标准库中实用的枚举option"><a class="header" href="#标准库中实用的枚举option">标准库中实用的枚举：Option</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
        None,
        Some(T),
    }
<span class="boring">}
</span></code></pre></pre>
<pre><code>enum Result&lt;T, E&gt; {
    OK(T),
    Err(E),
}
</code></pre>
<h2 id="七match控制流结构"><a class="header" href="#七match控制流结构">七.match控制流结构</a></h2>
<ul>
<li>
<p>前面流程控制简单说明了match使用，<strong>结合enum来看看match的更多使用场景总结</strong></p>
</li>
<li>
<p><strong>基础匹配语法：</strong></p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let number = 2;
    match number {
        1 | 2 =&gt; println!(&quot;1 or 2&quot;), // 匹配到某一个
        3..=5 =&gt; println!(&quot;3到5&quot;),  // 通过 ..= 匹配值的范围
        _ =&gt; println!(&quot;invalid&quot;),    //未匹配到 _
    }
<span class="boring">}
</span></code></pre></pre>
<h4 id="match-解构结构体"><a class="header" href="#match-解构结构体">match 解构结构体:</a></h4>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}

</code></pre></pre>
<h4 id="解构枚举"><a class="header" href="#解构枚举">解构枚举：</a></h4>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
    }
}
//打印结果到change the color....

</code></pre></pre>
<h4 id="解构嵌套的结构体和枚举"><a class="header" href="#解构嵌套的结构体和枚举">解构嵌套的结构体和枚举:</a></h4>
<pre><pre class="playground"><code class="language-rust">enum Color {
    Rgb(i32, i32, i32),
    Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; println!(
            &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
            h, s, v
        ),
        _ =&gt; (),
    }
}

</code></pre></pre>
<h4 id="用--忽略剩余值"><a class="header" href="#用--忽略剩余值">用 .. 忽略剩余值:</a></h4>
<pre><pre class="playground"><code class="language-rust">//通过使用 .. 来忽略 Point 中除 x 以外的字段
fn main() {
    struct Point {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = Point { x: 0, y: 0, z: 0 };

    match origin {
        Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
    }
}

</code></pre></pre>
<h4 id="match-guards"><a class="header" href="#match-guards"><strong>Match guards:</strong></a></h4>
<ul>
<li>匹配守卫（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let num = Some(4);
    match num {
        Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; (),
    }
}

</code></pre></pre>
<h4 id="绑定"><a class="header" href="#绑定"><strong>@绑定:</strong></a></h4>
<ul>
<li>运算符@，允许我们在创建一个存放值的变量的同时，测试其值是否匹配模式。即@ 可以在一个模式中同时测试和保存变量值。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    enum Message {
        Hello { id: i32 },
    }
    let msg = Message::Hello { id: 5 };
    match msg {
        Message::Hello {
            id: id_variable @ 3..=7, //使用id_variable变量配合@，以便此分支相关联的代码可以使用它
        } =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable),
        Message::Hello { id: 10..=12 } =&gt; {
            println!(&quot;Found an id in another range&quot;)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="精简笔记二"><a class="header" href="#精简笔记二">精简笔记二</a></h1>
<h2 id="八泛型trait生命周期"><a class="header" href="#八泛型trait生命周期">八，泛型、Trait、生命周期</a></h2>
<h4 id="泛型"><a class="header" href="#泛型">泛型：</a></h4>
<ul>
<li><strong>函数定义中使用泛型</strong></li>
</ul>
<pre><code>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
}
//函数 largest 有泛型类型 T。它有个参数 list，其类型是元素为 T 的 slice。largest 函数的返回值类型也是 T
//类型参数声明位于函数名称与参数列表中间的尖括号 &lt;&gt;
</code></pre>
<ul>
<li><strong>结构体定义中的泛型</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<ul>
<li><strong>枚举定义中的泛型</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}

<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>方法定义中的泛型</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<h4 id="trait"><a class="header" href="#trait">Trait：</a></h4>
<ul>
<li>通过 trait 以一种抽象的方式定义共享的行为,<em>trait</em>  类似于其他语言中的接口，但也不完全一样.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">//定义 trait Summary ,定义summarize调取-&gt;summarize_author默认方法，达到调用默认行为，区分开实现trait的的定义
pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}
//实现 trait Summary
impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}

fn main() {
    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
}

</code></pre></pre>
<ul>
<li><strong>trait 作为参数：</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 方法接收是实现了 trait Summary的类型
pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>Trait Bound：</strong> 
impl Trait 适用于短小的例子。trait bound 则适用于更复杂的场景，trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//使用相同类型的trait可以转换成下边的更简单写法
pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {}

// trait Bound的写法
pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>通过 <code>+</code> 指定多个 trait bound:</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p><strong>通过 <code>where</code> 简化 trait bound：</strong></p>
<p>每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="声明周期"><a class="header" href="#声明周期">声明周期：</a></h4>
<ul>
<li>
<p>Rust 中的每一个引用都有其 生命周期（lifetime），也就是引用保持有效的作用域，Rust 编译器有一个借用检查器（borrow checker）它比较作用域来确保所有的借用都是有效的</p>
</li>
<li>
<p><strong>函数签名中的生命周期注解：</strong></p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}

</code></pre></pre>
<ul>
<li>参数声明周期使用方法，或者靠编译器提示添加。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;i32        // 引用, 没有生命周期参数的 i32 的引用
&amp;'a i32     // 带有显式生命周期的引用 ，一个有叫做 'a 的生命周期参数的 i32 的引用
&amp;'a mut i32 // 带有显式生命周期的可变引用 一个生命周期也是 'a 的 i32 的可变引用

<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>结构体定义中的生命周期注解：</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}
fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<ul>
<li>
<p><strong>静态生命周期:</strong></p>
</li>
<li>
<p>生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 'static 生命周期</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<h2 id="九集合"><a class="header" href="#九集合">九，集合：</a></h2>
<h4 id="vector"><a class="header" href="#vector">vector:</a></h4>
<ul>
<li>类型是 Vec<T> 在内存中彼此相邻地排列所有的值, vector 只能储存相同类型的值</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  // Vec::new 创建
  let v: Vec&lt;i32&gt; = Vec::new();
  v.push(2);
  v.push(4);
  let x = v.pop();

<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>初始值来创建一个 Vec<T> :</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span> let v = vec![1, 2, 3];

<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>读取 vector 的元素:</strong>
使用 &amp;[index] 返回一个引用, 或者使用 get 方法以索引作为参数来返回一个 Option&lt;&amp;T&gt;。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    match v.get(2) {
        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
}
</code></pre></pre>
<ul>
<li><strong>使用枚举来储存多种类型:</strong>
创建一个储存枚举值的 vector，这样最终就能够通过vector存储实际是不同类型的值了</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
   enum SpreadsheetCell {
       Int(i32),
       Float(f64),
       Text(String),
   }
   let row = vec![
       SpreadsheetCell::Int(3),
       SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
       SpreadsheetCell::Float(10.12),
   ];
}
</code></pre></pre>
<h4 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10); //插入
    //只在键没有对应值时插入
    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);
    println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>more： https://doc.rust-lang.org/std/collections/index.html</li>
</ul>
<h2 id="十函数闭包迭代器"><a class="header" href="#十函数闭包迭代器">十，函数、闭包、迭代器</a></h2>
<h4 id="函数"><a class="header" href="#函数">函数：</a></h4>
<ul>
<li>函数的定义方式及在结构体实现里关联函数，关联函数与方法的使用区别</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::primitive;

struct Point {
    x: i32,
    y: i32,
}
impl Point {
    // 关联函数(没有self相关参数)
    fn new(x: i32, y: i32) -&gt; Point {
        Point { x: x, y: y }
    }
    // 方法(参数为&amp;self，是个隐示的，调用时无需传递表明是该类型而已）
    fn get_x(&amp;self) -&gt; i32 {
        self.x
    }
}
fn main() {
    //关联函数使用:: 方法使用类型.方法，如Point::new, point.get_x
    let point = Point::new(5, 6);
    println!(&quot;get x={}&quot;, point.get_x());
}

</code></pre></pre>
<h4 id="闭包"><a class="header" href="#闭包">闭包：</a></h4>
<ul>
<li>**闭包（closures）**是可以保存在一个变量中或作为参数传递给其他函数的匿名函数。 闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }  //函数的定义
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 }; // 完整标注的闭包定义
let add_one_v3 = |x|             { x + 1 };  // 闭包定义中省略了类型注解
let add_one_v4 = |x|               x + 1  ;  // 闭包体只有一行,去掉了大括号

<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>闭包会捕获其环境:</strong> </li>
<li>可以捕获其环境并访问其被定义的作用域的变量。如下边 x 并不是 equal_to_x 的一个参数，equal_to_x 闭包也被允许使用变量 x，因为它与 equal_to_x 定义于相同的作用域</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;
    let equal_to_x = |z| z == x;
    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<ul>
<li>
<p><strong><em>当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用，这会使用内存并产生额外的开销。</em></strong></p>
</li>
<li>
<p>闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，environment。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次
FnMut 获取可变的借用值所以可以改变其环境
Fn 从其环境获取不可变的借用值

<span class="boring">}
</span></code></pre></pre>
<p>由于所有闭包都可以被调用至少一次，所以所有闭包都实现了 FnOnce .<strong>大部分需要指定一个 Fn 系列 trait bound 的时候，可以从 Fn 开始，而编译器会根据闭包体中的情况告诉你是否需要 FnMut 或 FnOnce。</strong></p>
<ul>
<li><strong>带有泛型和 Fn trait 的闭包:</strong>
可以创建一个存放闭包和调用闭包结果的结构体, 目的：结构体只会在需要结果时执行闭包，并会缓存结果值，再次调用闭包可以复用该值.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}

<span class="boring">}
</span></code></pre></pre>
<p><em><strong>创建Cache的结构体，泛型T类型使用where 声明类型为闭包，结构体包含一个闭包，和一个用于存放闭包返回的值的u32类型，因为有可能第一次没有缓存，所有使用Option<u32>的类型。即可能是some(u32) 或者None</strong></em></p>
<ul>
<li><strong>官方完整例子：</strong></li>
</ul>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

struct Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    calculation: T,
    value: Option&lt;u32&gt;,
}

impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(u32) -&gt; u32,
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(&quot;Today, do {} pushups!&quot;, expensive_result.value(intensity));
        println!(&quot;Next, do {} situps!&quot;, expensive_result.value(intensity));
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}

fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}

</code></pre></pre>
<p><strong>a.这样可以起到了使用结构体缓存了闭包执行的结果，会先从结构体里查找缓存的值，没有再计算。
b.同理也可以改造value的类型为HashMap, 可以通过key来找值，避免返回之前计算的始终同一个值。</strong></p>
<h3 id="iterator"><a class="header" href="#iterator">iterator:</a></h3>
<ul>
<li>**迭代器（iterator):**负责遍历序列中的每一项和决定序列何时结束的逻辑。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();
    let total: i32 = v1_iter.sum();
    println!(&quot;value = {}&quot;, { total })
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>next 是 Iterator 实现者被要求定义的唯一方法</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let v1 = vec![1, 2, 3];
  let mut v1_iter = v1.iter();
  assert_eq!(v1_iter.next(), Some(&amp;1));

<span class="boring">}
</span></code></pre></pre>
<ul>
<li>调用 map 方法创建一个新迭代器，接着调用 collect 方法消费新迭代器并创建一个 vector</li>
</ul>
<pre><pre class="playground"><code class="language-rust">//next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None
fn main() {
    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];
    let mut newiter = v1.iter().map(|x| x + 1);
    let newVector: Vec&lt;_&gt; = newiter.collect();
    assert_eq!(newVector, vec![2, 3, 4]);
}

</code></pre></pre>
<ul>
<li><em><strong>迭代器 iter()、iter_mut()、into_iter()区别：</strong></em></li>
</ul>
<ol>
<li>iter()返回的是值的不可变引用. 即&amp;T</li>
<li>iter_mut() 返回的是值的可变引用. 即&amp;mut T</li>
<li>into_iter() 返回的是T类型的值 </li>
</ol>
<pre><pre class="playground"><code class="language-rust">use core::num;
fn main() {
    // iter() 返回的是值的不可变引用，即&amp;T.(此处map里闭包x本身无法改变)
    let vec = vec![1, 2, 3, 4];
    let new_vec: Vec&lt;_&gt; = vec.iter().map(|x| x + 1).collect();
    println!(&quot;{:?}&quot;, vec);
    println!(&quot;{:?}&quot;, new_vec);

    //iter_mut() 返回的是值的可变引用，即&amp;mut T.(此处map里闭包x本身+1)
    let mut vec = vec![1, 2, 3, 4];
    vec.iter_mut().for_each(|x| *x += 1);
    println!(&quot;{:?}&quot;, vec);

    //into_iter() 返回的是T类型的值  (因为所有权 vec是不能再使用)
    let vec = vec![1, 2, 3, 4];
    let new_vec: Vec&lt;_&gt; = vec.into_iter().filter(|x| *x == 2).collect();
    // println!(&quot;{:?}&quot;, vec); // 无法编译
    println!(&quot;{:?}&quot;, new_vec);
}
   
</code></pre></pre>
<ul>
<li><strong>实现Iterator trait 来创建自定义迭代器:</strong></li>
</ul>
<pre><code>struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

//Counter 类型实现 Iterator trait，通过定义 next 方法来指定使用迭代器时的行为
impl Iterator for Counter {
    type Item = u32; 
     //将迭代器的关联类型 Item 设置为 u32，意味着迭代器会返回 u32 值集合
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
</code></pre>
<ul>
<li>Rust里iterator的定义：</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust精简笔记-三"><a class="header" href="#rust精简笔记-三">Rust精简笔记 三</a></h1>
<h2 id="十一指针智能指针"><a class="header" href="#十一指针智能指针">十一，指针&amp;智能指针</a></h2>
<ul>
<li>指针是一个包含内存地址的变量的通用概念， 智能指针（smart pointers）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能</li>
<li>智能指针通常使用结构体实现，智能指针其实现了 Deref 和 Drop trait(离开作用域时运行的代码)</li>
</ul>
<h4 id="1-box-用于在堆上分配值"><a class="header" href="#1-box-用于在堆上分配值">1. Box<T> 用于在堆上分配值:</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let b = Box::new(1);
<span class="boring">}
</span></code></pre></pre>
<h4 id="2-rc-引用计数智能指针"><a class="header" href="#2-rc-引用计数智能指针">2. Rc<T> 引用计数智能指针:</a></h4>
<ul>
<li>Rc<T> 只能用于单线程场景</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   //Rc::clone 只会增加引用计数, 这样a,b都是指向1
    let a = Rc::new(1);
    let b = Rc::clone(&amp;a);
<span class="boring">}
</span></code></pre></pre>
<h4 id="3-refcellt-和内部可变性模式"><a class="header" href="#3-refcellt-和内部可变性模式">3. RefCell&lt;T&gt; 和内部可变性模式:</a></h4>
<ul>
<li><strong>RefCell&lt;T&gt; 代表其数据的唯一的所有权</strong>, 他具有如下特点:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在任意给定时刻，只能拥有一个可变引用或任意数量的不可变引用 之一（而不是两者）。
//引用必须总是有效的。

    let num = 1;
    let r1 = RefCell::new(1);
    // Ref - 只有一个不可变借用
    let r2 = r1.borrow();
    // RefMut - mutable  可变借用
    let r3 = r1.borrow_mut();
    // RefMut - 可变借用
    let r4 = r1.borrow_mut();
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><strong>内部可变性（Interior mutability):</strong>
是Rust 中的一个设计模式，它允许你即使在有不可变引用时也可以改变数据。</li>
<li>实现是通过不可变的Rc&lt;T&gt;, 此时的T的类型为RefCell&lt;T&gt;， <strong>即结合成Rc&lt;RefCell&lt;T&gt;&gt; 来实现内部可变性</strong>，而外部是无法修改的。</li>
<li>let value = Rc::new(RefCell::new(5)) 完整例子如下：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}


</code></pre></pre>
<h2 id="十二使用和引用模块代码"><a class="header" href="#十二使用和引用模块代码">十二，使用和引用模块代码：</a></h2>
<ul>
<li>模块的创建和引用</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn some_function() {}
mod outer_module {
    // private module
    pub mod inner_module {
        // public module
        pub fn inner_public_function() {
            super::super::some_function();
        }
        fn inner_private_function() {}
    }
}
fn main() {
    // 绝对路径 从 crate 根开始，以 crate 名或者字面值 crate 开头。
    crate::outer_module::inner_module::inner_public_function();
    //  相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。
    outer_module::inner_module::inner_public_function();
    // 使用 use 关键字将路径引入作用域
    use outer_module::inner_module;
    inner_module::inner_public_function();
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明周期-1"><a class="header" href="#声明周期-1">声明周期</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明周期-2"><a class="header" href="#声明周期-2">声明周期</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
